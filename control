#!/usr/bin/perl -w
use strict;
use IPC::Open2;
use Fcntl;
use Symbol 'gensym'; # vivify a separate handle for STDERR
use File::Spec;

# Communication with other programmes.  `mod_host` handles LV2
# effects.  `griode` runs the Launchpad X controller.
my $mod_host_port = 5555;
my $griode_port = 8887;

# Translation table for jack ports.  The names in the jack input lines
# are looked up in this hash.
my %JACK_PORTS = (
    MI_IN1 => 'system:capture_1',
    MI_IN2 => 'system:capture_2',
    MI_OUT1 => 'system:playback_1',
    MI_OUT2 => 'system:playback_2'
    );

# The history file keeps track of what changes this has made to jack
# and mod-host that have to be undone next run.  FIXME The history
# file is in a bad place.  Should not be able to write to the
# directory the script is in

## FIXME Use environment variable here.
my $ROOT =  $ENV{PATH_MI_ROOT};
-d $ROOT or die "'$ROOT' is not a directory:";

my $DIR = $ROOT;
$DIR =~ s/\/[^\/]+$/\//;
my $history_fn = "$DIR.history";
warn "History is: $history_fn";
-e $history_fn or `touch $history_fn`;
-r $history_fn or die "$!: Cannot read $history_fn ";
-w $history_fn or die "$!: Cannot read $history_fn ";

sub meter_bridge {
    my $pid_fn = "$DIR.meter_bridge.pid";
    if(-e $pid_fn){
	my $pid = `cat $pid_fn`;
	chomp $pid;
	kill 'HUP' , $pid;
    }
    
}

## Called when a `pedal...` command received
sub pedal( $ ) {
    my $pedal = shift or die;

    ## `$pedal` is a character in 'A', 'B', 'C'.  A choice of three
    ## pedals.
    -l 
}

sub mod_host( $ ){
    my $cmds = shift or die;
    my @cmds = @$cmds;

    my $pid =
	open2(my $child_out, my $child_in,
	      "/usr/bin/nc localhost $mod_host_port");
    defined $pid or die "$!: Fork failed";

    foreach my $cmd (@cmds){
	print $child_in "$cmd\n";

	my $result = '';
	while(1){
	    my $res = '';
	    read($child_out, $res, 1);

	    if($res eq "\n"){
		last;
	    }
	    if(ord($res) == 0){
		last;
	    }
	    $result .=  $res;
	}
	if($result =~ /resp ([\-0-9]+)/){
	    # If status is a negative number an error has
	    # occurred. The table below shows the number of each
	    # error.
	    
	    # status 	error
	    # -1 	ERR_INSTANCE_INVALID
	    # -2 	ERR_INSTANCE_ALREADY_EXISTS
	    # -3 	ERR_INSTANCE_NON_EXISTS
	    # -4 	ERR_INSTANCE_UNLICENSED
	    # -101 	ERR_LV2_INVALID_URI
	    # -102 	ERR_LV2_INSTANTIATION
	    # -103 	ERR_LV2_INVALID_PARAM_SYMBOL
	    # -104 	ERR_LV2_INVALID_PRESET_URI
	    # -105 	ERR_LV2_CANT_LOAD_STATE
	    # -201 	ERR_JACK_CLIENT_CREATION
	    # -202 	ERR_JACK_CLIENT_ACTIVATION
	    # -203 	ERR_JACK_CLIENT_DEACTIVATION
	    # -204 	ERR_JACK_PORT_REGISTER
	    # -205 	ERR_JACK_PORT_CONNECTION
	    # -206 	ERR_JACK_PORT_DISCONNECTION
	    # -301 	ERR_ASSIGNMENT_ALREADY_EXISTS
	    # -302 	ERR_ASSIGNMENT_INVALID_OP
	    # -303 	ERR_ASSIGNMENT_LIST_FULL
	    # -304 	ERR_ASSIGNMENT_FAILED
	    # -401 	ERR_CONTROL_CHAIN_UNAVAILABLE
	    # -402 	ERR_LINK_UNAVAILABLE
	    # -901 	ERR_MEMORY_ALLOCATION
	    # -902 	ERR_INVALID_OPERATION

	    #     A status zero or positive means that the command was
	    #     executed successfully. In case of the add command,
	    #     the status returned is the instance number. The
	    #     value field currently only exists for the param_get
	    #     command.
	    if($1 < 0){
		warn ">> $cmd >>  $result";
	    }
	}else{
	    warn "ERROR: $cmd -- '$result'\n";
	}
    }
    kill 'HUP' , $pid;
}    

sub write_history( @ ) {
    # warn "Write history to: $history_fn ";
    open(my $out, ">>$history_fn") or die $!;
    foreach my $l (@_) {
	print $out "$l\n";
    }
}

sub consume_stdin() {
    my $offset = 0;
    my $buffer;
    while(read(STDIN,  $buffer, 1, $offset++)){};
    return split(/\n/, $buffer);
}


#--------------------------------------------------------
#--------------------------------------------------------
#--------------------------------------------------------
# Set up the parameters of a instrument.  Set up LV2 effects, JACK
# connections, and GRIODE parameters

# A file of commands is prepared and the file name passed to this
# programme


# The mod-host works having a set of "effects".  Each one is added
# with the command:

# add <URL> <N>

# The <URL> identifies the effect (the command lv2ls lists all the
# URLs of installed LV2 effects).

# <N> is a unique number.  The Jack inputs/outputs are
# `effect_N:input`/`effect_N:output`

# When a valid `add` command in received a record is created by adding
# a line: "<N> <URL>\n"

# When a parameter is using command `param_set` a line is added `<N>
# <param_name,value>...<param_name,value>`

# On startup the parameters are read into a hash keyed by N, value is
# a HASHREF.  One enty is `url => <URL>`.  Each parameter uses the
# parameter name as a key and the value is a array of values. (are
# they allways numbers?)

#


my @stdin;
if(scalar(@ARGV) == 0){
    # No argument.  Read stdin
    
    @stdin = consume_stdin();
}elsif(scalar(@ARGV) == 1){
    # One arg, a path
    open(my $in, $ARGV[0]) or die "$!: $ARGV[0]";
    @stdin = <$in>;
}
#print join("\n", @stdin)."\n---\n";

# Place tostore commands before being executed.
my @griode = ();
my @modhost = ();
my @jack = ();


# Commands on command line.
# `mh`  a mod host parameter to set
# Else a file name that holds commannds to initialise a instrument

foreach my $line (@stdin){
    $line =~ /\S/ or next;
    $line =~ /^\s*\#/ and next;
    chomp $line;
    
    $line =~ /^(\S+)\s?(.*)?/ or die $line;
    my $arg1 = $1;
    my $args = defined($2) ? $2 : "";
    
    if($arg1 eq 'griode'){
	# Send a command to griode
	push(@griode, $args);
    }elsif($arg1 eq 'mh'){
	# Could be a `add` instruction to create a mod-host efect or
	# `param_set` to set parameters
	if($args =~ /^\s*(add)\s+.+$/ ||
	   $args =~ /^\s*param_set\s/ ||
	   $args =~ /^\s*remove\s/){
	    push(@modhost,  $args);
	}
    }elsif($arg1 eq 'jack'){
	push(@jack, $args);
    }elsif($arg1 eq 'clear'){
	# If there is no history there is nothing to clear
	my $s = -s $history_fn;
	if($s > 0){
	    # Read history and undo commands run earlier and undo them
	    my @history = `cat $history_fn`;

	    my %jack_hist = ();
	    my %modh_hist = ();

	    foreach my $cmd (@history) {
		# warn "\$cmd $cmd";
		# jack and mod-host commands are the only ones we need to undo
		if($cmd =~ /^jack\s(\S+ \S+)\s*$/){
		    $jack_hist{$1} = $1;
		}elsif($cmd =~ /add\s\S+\s+(\d+)\s*$/){
		    $modh_hist{$1} = $1;
		}	    
	    }
	    map {`jack_disconnect $_`} keys %jack_hist;
	    map{  mod_host([["remove", "remove $_"]])} keys %modh_hist;
	    # warn "Deleted history\n";

	    unlink $history_fn;
	}
    }else{
	die $arg1;
    }
}

if(@griode){
    #warn "Griode commands: ".scalar(@griode)." \n";    
    open(my $out_fh, "|-", "/usr/bin/nc localhost $griode_port")
	or die $!;
    map {print $out_fh "$_\n"} @griode;
    close $out_fh or die $!;
    write_history(map{'griode '.$_} @griode);
}
if(@modhost){
    # print "mod-host\n";
    my $start  = time();
    mod_host(\@modhost);
    # print "mod-host: ".(time() - $start) . " seconds\n";
    write_history(map{'mod-host '. $_} @modhost);
}
if(@jack){
    # warn "jack\n";
    foreach my $cmd (@jack){
	foreach my $lhs (keys %JACK_PORTS){
	    my $rhs = $JACK_PORTS{$lhs};
	    $cmd =~ s/$lhs/$rhs/g;
	}
	## Could use mod_host here.  May be quicker....
	`jack_connect $cmd`;
	write_history(('jack '.$cmd));
    }
}

## 
