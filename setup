#!/usr/bin/perl -w
use strict;
use IPC::Open2;
use Fcntl;
use Symbol 'gensym'; # vivify a separate handle for STDERR
use File::Spec;

# Set up the parameters of a instrument.  Set up LV2 effects, JACK
# connections, and GRIODE parameters

# A file of commands is prepared and the file name passed to this
# programme

# Communication with other programmes.  `mod_host` handles LV2
# effects.  `griode` runs the Launchpad X controller.
my $mod_host_port = 5555;
my $griode_port = 8887;



# The history file keeps track of what changes this has made to jack
# and mod-host that have to be undone next run
my $history_fn = '.history';
-e $history_fn or `touch $history_fn`;
-r $history_fn or die "$!: Cannot read $history_fn ";
-w $history_fn or die "$!: Cannot read $history_fn ";

# The mod-host works having a set of "effects".  Each one is added
# with the command:

# add <URL> <N>

# The <URL> identifies the effect (the command lv2ls lists all the
# URLs of installed LV2 effects).

# <N> is a unique number.  The Jack inputs/outputs are
# `effect_N:input`/`effect_N:output`

# When a valid `add` command in received a record is created by adding
# a line: "<N> <URL>\n"

# When a parameter is using command `param_set` a line is added `<N>
# <param_name,value>...<param_name,value>`

# On startup the parameters are read into a hash keyed by N, value is
# a HASHREF.  One enty is `url => <URL>`.  Each parameter uses the
# parameter name as a key and the value is a array of values. (are
# they allways numbers?)

#
sub griode_command( $ ){
    my $c = shift or die;

}    

# Read in history
sub mod_host( $$ ){
    my ($c, $rest) = @_;
    # `mod-host` command

    my $pid =
	open2(my $child_out, my $child_in, "/usr/bin/nc localhost $mod_host_port");
    defined $pid or die "$!: Fork failed";
    #print "Sending command: $c";
    print $child_in "$c $rest";

    my $result = '';
    while(1){
	my $res = '';
	read($child_out, $res, 1);
	if($res eq "\n"){
	    last;
	}
	if(ord($res) == 0){
	    last;
	}
	$result .=  $res;
	# FIXME  Process $res for errors
    }
    $result .= "\n";
    kill 'HUP' , $pid;
    return $result;
}    

# Set up effects in mod-host

# Start up a `nc 127.0.0.1 $mod_host_port ` and send commands to it

# Pass file name on command line that holds commands
my $command_fn = shift or die "No file name passed";
-r $command_fn or die "$!: Cannot read file: $command_fn";
open(my $in, $command_fn) or die "$!: Cannot open $command_fn";
my @commands = <$in>;
close($in);

# Read history and undo commands run earlier and undo them
my @history = `cat $history_fn`;
foreach my $cmd (@history) {
    # jack and mod-host commands are the only ones we need to undo
    if($cmd =~ /^jack\s(\S+ \S+)\s*$/){
	print `jack_disconnect $1`;
    }elsif($cmd =~ /add\s\S+\s+(\d+)\s*$/){
	print mod_host("remove", $1);
    }	    
}

foreach my $cmd (@commands){
    
    ## Comments and blank lines
    $cmd =~ /^\s*\#/ and next;
    $cmd =~ /\S/ or next;
    chomp $cmd;
    
    # Three sorts of command:
    # 1 Effect add/parameter setting for mod-host
    # A jack connection
    # Commands to send to griode

    # `mod-host` commands are sent via `nc`, the others using ``
    `echo $cmd >> $history_fn`;
    $cmd =~ /^(\S+)\s+(.+)\s*$/ or die "$cmd ";

    my $c = $1;
    my $rest = $2;
    my $res;
    if($c eq "add" or $c eq "param_set"){
	$res = mod_host($c, $rest);
    }elsif($c eq "griode"){
	open(my $out_fh, "|-", "/usr/bin/nc localhost $griode_port")
	    or die $!;
	print $out_fh "$rest";
	$res = '';
    }elsif($c eq 'jack'){
	$res = `jack_connect $rest`;
    }
    print $res;
}

