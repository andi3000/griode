#!/usr/bin/perl -w
use strict;
use IPC::Open2;
use Fcntl;
use Symbol 'gensym'; # vivify a separate handle for STDERR
use File::Spec;

# Set up the parameters of a instrument.  Set up LV2 effects, JACK
# connections, and GRIODE parameters

# A file of commands is prepared and the file name passed to this
# programme

# The state file keeps track of what `status` has done to `mod-host`
my $state_fn = '.state';
-e $state_fn or `touch $state_fn`;
-r $state_fn or die "$!: Cannot read $state_fn ";
-w $state_fn or die "$!: Cannot read $state_fn ";

# Data about LV2 effects is stored in the state file: (TODO: Expand to
# hold JACK/GRIODE state as well)

# The mod-host works having a set of "effects".  Each one is added
# with the command:

# add <URL> <N>

# The <URL> identifies the effect (the command lv2ls lists all the
# URLs of installed LV2 effects).

# <N> is a unique number.  The Jack inputs/outputs are
# `effect_N:input`/`effect_N:output`

# When a valid `add` command in received a record is created by adding
# a line: "<N> <URL>\n"

# When a parameter is using command `param_set` a line is added `<N>
# <param_name,value>...<param_name,value>`

# On startup the parameters are read into a hash keyed by N, value is
# a HASHREF.  One enty is `url => <URL>`.  Each parameter uses the
# parameter name as a key and the value is a array of values. (are
# they allways numbers?)

# Read in state
sub read_state_file(){

    my %state = ();
    open(my $statefh, $state_fn) or die $!;
    while(my $line = <$statefh>){
	chomp $line;
	$line =~ /^(\d+)\s+(.+)\s*$/ or die "$line ";
	my $N = $1;
	my $rest = $2;
	defined($state{$N}) or $state{$N} = {};
	if($rest =~ /^http/){
	    # A url
	    $state{$N}->{URL} = $rest;
	}elsif($rest =~ /^(\S+)\s+(.+)\s*$/){
	    # Parameters
	    my $name = $1;
	    my $values = $2;
	    my %values = map{/^(\S+),(\d+)/ or die "$_: $line ";
			     $1 => $2
	    }
	    split(/\s+/, $values);

	    map { $state{$N}->{$_} = $values{$_}} keys %values;
	}else{
	    die $line;
	}
    }
    return %state;
}
# Write out state
sub write_state_file( $ ){
    my $state_ref = shift or die;
    my %state = %$state_ref;
    open(my $statefh, ">$state_fn") or die $!;
    foreach my $N (sort {$a <=> $b} keys %state){
	my $url = $state{$N}->{URL} or die $N;
	$url =~ /^http/ or die $url;
	print $statefh "$N $url\n";
	foreach my $param (sort grep {$_ !~ /URL/} keys %{$state{$N}}){
	    print $statefh "$N $param $state{$N}->{$param}\n";
	}
    }
}
my %state = &read_state_file;

# Set up effects in mod-host
my $port = 5555;

# Start up a `nc 127.0.0.1 $port ` and send commands to it

# Pass file name on command line that holds commands
my $command_fn = shift or die "No file name passed";
-r $command_fn or die "$!: Cannot read file: $command_fn";
open(my $in, $command_fn) or die "$!: Cannot open $command_fn";
my @commands = <$in>;
close($in);

#my $pid = open(my $nc, "|-", "/usr/bin/nc localhost $port") or die $!;
foreach my $cmd (@commands){

    # Three sorts of command:
    # 1 Effect add/parameter setting for mod-host
    # A jack connection
    # Commands to send to griode

    # The first (mod-host commands) start either with "add " or
    # "param_set "

    # The second starts with "echo "

    # The third with "jack_connect"

    # `mod-host` commands are sent via `nc`, the others via the shell
    
    $cmd =~ /^(\S+)\s+(.+)\s*$/ or die "$cmd ";

    my $cmd = $1;
    my $rest = $2;

    if($cmd eq "add" or $cmd eq "param_set"){
	# `mod-host` command
	my $N;
	if($cmd eq "param_set"){
	    # param_set 1 delay_base 30
	    $rest =~ /^(\d+)\s/ or die $cmd;
	    $N = $1;
	}else{
	    $rest =~ /(\d+)\s*$/ or die $cmd;
	    $N = $1;
	}
	defined $N or die $cmd;
	defined($state{$N}) or $state{$N}= {};
	if($cmd eq "add"){
	    # A url
	    $rest =~ /^(http\S+)/ or die $cmd;
	    $state{$N}->{URL} = $1;
	}else{
	    # Parameter
	    $rest =~ /^$N\s(\S+)\s([\d\.]+)/ or die $cmd;
	    my $name = $1;
	    my $value = $2;
	    $state{$N}->{$name} = $value;
	}
	

	my $pid =
	    open2(my $child_out, my $child_in, "/usr/bin/nc localhost $port");
	defined $pid or die "$!: Fork failed";
	
	print "Sending command: $cmd";
	print $child_in "$cmd $rest";

	my $res = '';
	while(1){
	    read($child_out, $res, 1);
	    if($res eq "\n"){
		last;
	    }
	    if(ord($res) == 0){
		last;
	    }
	    print $res;
	    # FIXME  Process $res for errors
	}
	print "\n";
	
	kill 'HUP' , $pid;
    }else{
	# Just use the shell.  This would be a security hole a mile
	# wide if anybody cared...
	my $res = `$cmd`;
	# FIXME Process $res for errors
    }
}
&write_state_file( \%state );
