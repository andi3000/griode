#!/usr/bin/perl -w
use strict;
use IPC::Open2;
use Fcntl;
use Symbol 'gensym'; # vivify a separate handle for STDERR
use File::Spec;

# Set up the parameters of a instrument.  Set up LV2 effects, JACK
# connections, and GRIODE parameters

# A file of commands is prepared and the file name passed to this
# programme

# Communication with other programmes.  `mod_host` handles LV2
# effects.  `griode` runs the Launchpad X controller.
my $mod_host_port = 5555;
my $griode_port = 8887;



# The history file keeps track of what changes this has made to jack
# and mod-host that have to be undone next run
my $pwd = `pwd`;
chomp $pwd;
my $history_fn = $pwd.'/.history';
-e $history_fn or `touch $history_fn`;
-r $history_fn or die "$!: Cannot read $history_fn ";
-w $history_fn or die "$!: Cannot read $history_fn ";

# The mod-host works having a set of "effects".  Each one is added
# with the command:

# add <URL> <N>

# The <URL> identifies the effect (the command lv2ls lists all the
# URLs of installed LV2 effects).

# <N> is a unique number.  The Jack inputs/outputs are
# `effect_N:input`/`effect_N:output`

# When a valid `add` command in received a record is created by adding
# a line: "<N> <URL>\n"

# When a parameter is using command `param_set` a line is added `<N>
# <param_name,value>...<param_name,value>`

# On startup the parameters are read into a hash keyed by N, value is
# a HASHREF.  One enty is `url => <URL>`.  Each parameter uses the
# parameter name as a key and the value is a array of values. (are
# they allways numbers?)

#


sub mod_host( $ ){
    my $cmds = shift or die;
    my @cmds = @$cmds;
    # `mod-host` command

    my $pid =
	open2(my $child_out, my $child_in, "/usr/bin/nc localhost $mod_host_port");
    defined $pid or die "$!: Fork failed";
    #print "Sending command: $c";
    foreach my $cmd (@cmds){
	print $child_in "$cmd->[0] $cmd->[1]\n";

	my $result = '';
	while(1){
	    my $res = '';
	    read($child_out, $res, 1);

	    if($res eq "\n"){
		last;
	    }
	    if(ord($res) == 0){
		last;
	    }
	    $result .=  $res;
	    # FIXME  Process $res for errors
	}
	$result =~ /resp ([\-0-9]+)/ or die "'$result'";
	# if($1 < 0){
	    print ">> $result\n";
	# }
    }
    kill 'HUP' , $pid;
}    

sub write_history( @ ) {
    open(my $out, ">>$history_fn") or die $!;
    foreach my $l (@_) {
	print $out "$l\n";
    }
}

sub consume_stdin() {
    my $offset = 0;
    my $buffer;
    while(read(STDIN,  $buffer, 1, $offset++)){};
    return split(/\n/, $buffer);
}

my @stdin = consume_stdin();
print join("\n", @stdin)."\n---\n";


# Place tostore commands before being executed.
my @griode = ();
my @modhost = ();
my @jack = ();


# Commands on comand line.
# `mh`  a mod host parameter to set
# Else a file name that holds commannds to initialise a instrument

foreach my $line (@stdin){
    $line =~ /\S/ or next;
    $line =~ /^\s*\#/ and next;
    chomp $line;
    
    $line =~ /^(\S+)\s?(.*)?/ or die $line;
    my $arg1 = $1;
    my $args = defined($2) ? $2 : "";
    
    if($arg1 eq 'G'){
	# Send a command to griode
	push @griode, $args;
    }elsif($arg1 eq 'mh'){
	$args =~ /^\s*(\S+)\s+(\S+)\s+(\S+)\s*$/ or die $args;
	my $n = $1;
	my $s = $2;
	my $v = $3;
	warn "$n $s $v";
	push(@modhost, ["param_set", $args]);
    }else{
	my $command_fn = $arg1;
	-r $command_fn or die "$!: Cannot read file: $command_fn";
	open(my $in, $command_fn) or die "$!: Cannot open $command_fn";
	my @commands = <$in>;
	close($in);
	warn "Read commands\n";

	# Read history and undo commands run earlier and undo them
	my @history = `cat $history_fn`;
	unlink $history_fn;
	my @jack_hist = ();
	my @modh_hist = ();

	foreach my $cmd (@history) {
	    # jack and mod-host commands are the only ones we need to undo
	    if($cmd =~ /^jack\s(\S+ \S+)\s*$/){
		push(@jack_hist, $1);
	    }elsif($cmd =~ /add\s\S+\s+(\d+)\s*$/){
		push(@modh_hist, $1);
	    }	    
	}
	map {print `jack_disconnect $_`} @jack_hist;
	map{ print mod_host([["remove", $_]])} @modh_hist;
	warn "Deleted history\n";
	foreach my $cmd (@commands){
	    
	    ## Comments and blank lines
	    $cmd =~ /^\s*\#/ and next;
	    $cmd =~ /\S/ or next;
	    chomp $cmd;
	    
	    # Three sorts of command:
	    # 1 Effect add/parameter setting for mod-host
	    # A jack connection
	    # Commands to send to griode

	    # `mod-host` commands are sent via `nc`, the others using ``
	    $cmd =~ /^(\S+)\s+(.+)\s*$/ or die "$cmd ";

	    my $c = $1;
	    my $rest = $2;
	    my $res;
	    if($c eq "add" or $c eq "param_set"){
		push(@modhost, [$c, $rest]);
		# $res = mod_host($c, $rest);
	    }elsif($c eq "griode"){
		push(@griode, $rest);
	    }elsif($c eq 'jack'){
		push(@jack, $rest);
		# $res = `jack_connect $rest`;
	    }
	}
    }

    if(@griode){
	warn "Griode\n";    
	open(my $out_fh, "|-", "/usr/bin/nc localhost $griode_port")
	    or die $!;
	map {print $out_fh "$_\n"} @griode;
	close $out_fh or die $!;
	write_history(map{'griode '.$_} @griode);
    }
    if(@modhost){
	warn "mod-host\n";
	mod_host(\@modhost);
	write_history(map{'mod-host '. join(' ', @$_)} @modhost);
    }
    if(@jack){
	warn "jack\n";
	map{print `jack_connect $_`} @jack;
	write_history(map{'jack '.$_} @jack);
    }

}
